<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on /dev/null</title>
    <link>http://elder-george.github.io/post/</link>
    <description>Recent content in Posts on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Oct 2021 22:45:14 -0700</lastBuildDate><atom:link href="http://elder-george.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hashtables &amp; C&#43;&#43; - part 2</title>
      <link>http://elder-george.github.io/post/hashtables-2/</link>
      <pubDate>Sat, 23 Oct 2021 22:45:14 -0700</pubDate>
      
      <guid>http://elder-george.github.io/post/hashtables-2/</guid>
      <description>(this is a continuation of the previous post)
After playing with performance of the standard (and semi-standard) hashtables, I wondered, if it&amp;rsquo;s hard enough to do my own hashmap to work better than the std::unordered_map. Algorithms and data structures aren&amp;rsquo;t my strongest skills, so I wondered what can I learn here.
(note: we&amp;rsquo;re not bound by STL interfaces here, we&amp;rsquo;re free to do our own; I&amp;rsquo;m going to keep calling the main method try_emplace, but that&amp;rsquo;s all)</description>
    </item>
    
    <item>
      <title>Hashtables &amp; C&#43;&#43; - part 1</title>
      <link>http://elder-george.github.io/post/hashtables/</link>
      <pubDate>Sat, 23 Oct 2021 21:02:11 -0700</pubDate>
      
      <guid>http://elder-george.github.io/post/hashtables/</guid>
      <description>Not long ago I stumbled upon this post discussing different approaches to string interning.
The author did 4 implementations: (quote)
   A control in pure C,
  a Trie in pure C,
  a hand rolled hash table in pure C,
  and an std::unordered_map (hash table) wrapper, in C++.
   The benchmarked it and found, among other things, that the C++ version was the slowest of them all.</description>
    </item>
    
  </channel>
</rss>
